# -*- coding: utf-8 -*-
"""Generates parameter configuration for RadTrack from a spreadsheet.

Translates ``util/parameters.xlsx`` to ``util/parameters.py``, which is a collection of
classes holding state.

How to import::

    import util.parameters as params

:copyright: Copyright (c) 2015 RadiaBeam Technologies LLC.  All Rights Reserved.
:license: Apache, see license.md for more details.
"""

from __future__ import print_function
from future.utils import viewitems
import __builtin__
import re
import os.path
import sys

import argh
import openpyxl

HEADINGS = [
    'py_name', 'display_name', 'py_type', 'default', 'units', 'is_primary', 'description']
VALID_TYPES = dict([(t, getattr(__builtin__, t)) for t in ['int', 'str', 'float', 'bool']])
NUMERIC_TYPES = [int, float]
#TODO(robnagler): these should be types or instances
VALID_UNITS = ['m', 'um', 'in']

def parse_and_write(parameters_xlsx, parameters_py='parameters.py'):
    """Parse parameters_xlsx and generate parameters.py in same dir as
    this file. (parameters_py is used for testing.)
    """
    parsed = _parse(parameters_xlsx)
    out_filename = os.path.join(
        os.path.dirname(os.path.abspath(__file__)), parameters_py)
    with open(out_filename, 'w') as out:
        template = '''
# -*- coding: utf-8 -*-
"""Parameter declarations.

This file is dynamically generated from {}.

DO NOT EDIT THIS FILE. Your changes will be overwritten.
"""
'''
        out.write(template.format(parameters_xlsx))
        for sheet, attrs in viewitems(parsed):
            _write_class(sheet, attrs, out)
    return out_filename

def _parse(parameters_xlsx):
    """Read parameters_xlsx and produce an internal tree of sheets and params"""
    err_prefix = parameters_xlsx
    try:
        wb = openpyxl.load_workbook(parameters_xlsx)
        res = {}
        err_prefix_file = err_prefix
        for raw_sheet in wb:
            err_prefix = '{}, sheet {}'.format(err_prefix_file, raw_sheet.title)
            err_prefix_sheet = err_prefix
            st = _utf8(raw_sheet.title)
            res[st] = sheet = {
                'title': _parse_id(st, res, 'sheet title'),
                'rows': {},
            }
            for row_num, raw_row in enumerate(raw_sheet.rows, start=1):
                err_prefix = '{}, row {}'.format(err_prefix_sheet, row_num)
                row = map(lambda r: _utf8(r.value), raw_row)
                if row_num == 1:
                    sheet['description'] = _parse_sheet_description(row, sheet)
                elif row_num == 2:
                    _parse_headings(row)
                else:
                    r = _parse_param(row, sheet)
                    sheet[r['py_name']] = r
            assert row_num > 2, 'too few rows'
        return res
    except Exception as e:
        raise type(e), type(e)('{}: {}'.format(err_prefix, e)), sys.exc_info()[2]

def _parse_headings(row):
    """Do the headings match for this sheet?"""
    for cell, h in zip(row, HEADINGS):
        assert cell == h, \
            'mismatched heading: expected {}, but got {}'.format(h, cell)

def _parse_id(name, names, which):
    """Verify sheet or parameter name is a valid identifier and not a duplicate"""
    assert name, 'missing {}'.format(which)
    assert name not in names, 'duplicate {}'.format(which)
    assert re.search(r'^[a-z][a-z0-9_]*$', name, flags=re.IGNORECASE), \
        '{} is invalid python identifer'.format(which)
    return name

def _parse_param(row, sheet):
    """Parse a parameter row, validating type, default, and py_name"""
    assert len(row) == len(HEADINGS), \
        'incorrect number of columns ({})'.format(len(row))
    row = dict(zip(HEADINGS, row))
    row['py_name'] = _parse_id(row['py_name'], sheet['rows'], 'parameter name')
    row['py_type'] = _parse_param_type(row)
    row['default'] = _parse_param_default(row)
    row['units'] = _parse_param_units(row)
    return row


def _parse_param_default(row):
    """Verify parameter default matches type"""
    if row['default'] is None:
        return None
    return row['py_type'](row['default'])

def _parse_param_type(row):
    """Is type in the known list?"""
    assert row['py_type'] in VALID_TYPES, \
        '{}: invalid py_type'.format(row['py_type'])
    return VALID_TYPES[row['py_type']]

def _parse_param_units(row):
    t = row['py_type']
    u = row['units']
    if u is None:
        assert t not in NUMERIC_TYPES, \
            'must provide units for type "{}"'.format(t)
    else:
        assert u in VALID_UNITS, \
            'unknown units "{}"'.format(u)
        assert t in NUMERIC_TYPES, \
            'units "{}" not acceptable for type "{}"'.format(u, t)
    return u

def _parse_sheet_description(row, sheet):
    """Verify sheet description is defined and not too short"""
    d = row[0]
    min_len = 10
    assert d is not None and len(d) >= min_len, \
        '{}: description must be at least {} chars, but is only '.format(
            d, min_len, len(sheet['title']))
    return d

def _utf8(value):
    if value is not None and hasattr(value, 'encode'):
        return value.encode('utf-8')
    return value

def _write_class(name, attrs, out):
    """Write the class header"""
    template = '''
class {}:
    """{}"""

'''
    out.write(template.format(name, attrs['description']))
    for param, param_attrs in viewitems(attrs['rows']):
        _write_param(param, param_attrs, out)

def _write_param(name, attrs, out):
    """Ouptut a single parameter initialized with its default value"""
    v = attrs['default']
    if v is not None:
        t = attrs['py_type']
        if t != bool:
            if t == str:
                v = 'u' + repr(v)
            else:
                v = '{}({})'.format(t.__name__, v)
    out.write(u'    {} = {}\n'.format(name, v))

# types are classes so have name space for values, e.g. py_int.MC is class
# so that you can assign (int works) and also get at attributes of the values,
# e.g. default, py_type, display_name, etc. Can also call getattr to get
# attributes of the value. Do we go with the MC comment? Look for other classes
# Implement tests first, because they won't change for assignment.
# Assignments in above will verify types naturally

if __name__ == '__main__':
    argh.dispatch_commands([parse_and_write])
